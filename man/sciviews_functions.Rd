% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sciviews_functions.R
\name{sciviews_functions}
\alias{sciviews_functions}
\alias{list_sciviews_functions}
\alias{all_of}
\alias{as.grouped_df}
\alias{as_grouped_df}
\alias{as.grouped_df.default}
\alias{as.grouped_df.grouped_df}
\alias{as.grouped_df.GRP_df}
\alias{print.grouped_df}
\alias{group_vars_}
\alias{group_rows_}
\alias{group_data_}
\alias{group_indices_}
\alias{group_keys_}
\alias{groups_}
\alias{group_size_}
\alias{n_groups_}
\alias{group_by_}
\alias{ungroup_}
\alias{rename_}
\alias{rename_with_}
\alias{filter_}
\alias{select_}
\alias{mutate_}
\alias{transmute_}
\alias{summarise_}
\alias{summarize_}
\alias{reframe_}
\alias{arrange_}
\alias{pull_}
\alias{join_}
\alias{right_join_}
\alias{full_join_}
\alias{left_join_}
\alias{inner_join_}
\alias{semi_join_}
\alias{anti_join_}
\alias{bind_rows_}
\alias{bind_cols_}
\alias{slice_}
\alias{slice_head_}
\alias{slice_tail_}
\alias{count_}
\alias{tally_}
\alias{add_count_}
\alias{add_tally_}
\alias{distinct_}
\alias{drop_na_}
\alias{replace_na_}
\alias{pivot_longer_}
\alias{pivot_wider_}
\alias{uncount_}
\alias{unite_}
\alias{fill_}
\alias{separate_}
\title{SciViews functions (mainly from collapse and data.table) to manipulate data frames}
\usage{
list_sciviews_functions()

all_of(x)

as.grouped_df(x, ...)

as_grouped_df(x, ...)

\method{as.grouped_df}{default}(x, ...)

\method{as.grouped_df}{grouped_df}(x, ...)

\method{as.grouped_df}{GRP_df}(x, ...)

\method{print}{grouped_df}(x, ...)

group_vars_(.data = (.), return = "names")

group_rows_(.data = (.))

group_data_(.data = (.))

group_indices_(.data = (.), ...)

group_keys_(.data = (.), ...)

groups_(.data = (.))

group_size_(.data = (.))

n_groups_(.data = (.))

group_by_(
  .data = (.),
  ...,
  .add = FALSE,
  .drop = NULL,
  .sort = get_collapse("sort"),
  .decreasing = FALSE,
  .na.last = TRUE,
  .return.groups = TRUE,
  .return.order = .sort,
  .method = "auto"
)

ungroup_(.data = (.), ..., .na.last = TRUE, .method = "auto")

rename_(.data = (.), ...)

rename_with_(.data = (.), .fn, .cols = ~everything(), ...)

filter_(.data = (.), ..., .by = NULL, .preserve = FALSE)

select_(.data = (.), ...)

mutate_(
  .data = (.),
  ...,
  .by = NULL,
  .keep = "all",
  .before = NULL,
  .after = NULL,
  .cols = NULL
)

transmute_(.data, ...)

summarise_(
  .data = (.),
  ...,
  .by = NULL,
  .groups = "drop_last",
  .keep.group_vars = TRUE,
  .cols = NULL
)

summarize_(
  .data = (.),
  ...,
  .by = NULL,
  .groups = "drop_last",
  .keep.group_vars = TRUE,
  .cols = NULL
)

reframe_(
  .data,
  ...,
  .by = NULL,
  .groups = "drop",
  .keep.group_vars = TRUE,
  .cols = NULL
)

arrange_(
  .data = (.),
  ...,
  .by_group = FALSE,
  .locale = "C",
  .decreasing = FALSE
)

pull_(.data = (.), var = -1, name = NULL, ...)

join_(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL,
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL,
  how = "full"
)

right_join_(
  x = (.),
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL,
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL
)

full_join_(
  x = (.),
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  relationship = NULL,
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL
)

left_join_(
  x = (.),
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL,
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL
)

inner_join_(
  x = (.),
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL,
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL
)

semi_join_(
  x = (.),
  y,
  by = NULL,
  copy = FALSE,
  ...,
  na_matches = c("na", "never"),
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL
)

anti_join_(
  x = (.),
  y,
  by = NULL,
  copy = FALSE,
  ...,
  na_matches = c("na", "never"),
  sort = FALSE,
  verbose = 0,
  column = NULL,
  attr = NULL
)

bind_rows_(..., .id = NULL, .use_names = TRUE, .fill = TRUE)

bind_cols_(
  ...,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)

slice_(.data = (.), ..., .by = NULL, .preserve = NULL)

slice_head_(.data = (.), ..., n = 1L, prop, by = NULL, sort = TRUE)

slice_tail_(.data = (.), ..., n = 1L, prop, by = NULL, sort = TRUE)

count_(
  .data = (.),
  ...,
  wt = NULL,
  name = "n",
  sort = FALSE,
  decreasing = TRUE,
  .drop = TRUE,
  add = FALSE
)

tally_(.data = (.), wt = NULL, name = "n", sort = FALSE, decreasing = TRUE)

add_count_(
  .data = (.),
  ...,
  wt = NULL,
  name = "n",
  sort = FALSE,
  decreasing = TRUE,
  .drop = TRUE
)

add_tally_(.data = (.), wt = NULL, name = "n", sort = FALSE, decreasing = TRUE)

distinct_(.data = (.), ..., .keep_all = FALSE, .method = "auto")

drop_na_(.data = (.), ..., .na.attr = FALSE, .prop = 0)

replace_na_(.data = (.), replace, ..., v = NULL)

pivot_longer_(
  .data = (.),
  cols,
  ...,
  cols_vary = "fastest",
  names_to = "name",
  names_prefix = NULL,
  values_to = "value",
  values_drop_na = FALSE,
  factor = FALSE
)

pivot_wider_(
  .data = (.),
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = name,
  names_prefix = "",
  names_vary = "fastest",
  values_from = value,
  values_fill = NULL,
  values_fn = "last",
  drop = TRUE,
  sort = FALSE
)

uncount_(.data = (.), weights, ..., .remove = TRUE, .id = NULL)

unite_(.data = (.), col, ..., sep = "_", remove = TRUE, na.rm = FALSE)

fill_(.data = (.), ..., .direction = "down")

separate_(
  .data = (.),
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  fixed = FALSE,
  ...
)
}
\arguments{
\item{x}{A data frame (data.frame, data.table or tibble's tbl_df).}

\item{...}{Arguments dependent to the context of the function and most of
the time, not evaluated in a standard way (cf. the tidyverse approach).}

\item{.data}{A data frame (data.frame, data.table or tibble's tbl_df)}

\item{return}{What to return: \code{"data"} or \code{1}, \code{"unique"} or \code{2} for unique
rows of grouping columns, \code{"names"} or \code{3} (default) for names of grouping
columns, \code{"indices"} or \code{4} for integer indices of grouping columns,
\code{"named_indices"} or \code{5} for named indices, \code{"logicial"} or \code{6} for logical
selection vector of grouping columns, or \code{"named_logical"} or \code{7} for named
logical.}

\item{.add}{If \code{TRUE}, the grouping variables are added to the existing ones.}

\item{.drop}{Are levels with no observations dropped (\code{TRUE} by default).}

\item{.sort}{If \code{TRUE} groups are sorted.}

\item{.decreasing}{Is sorting done in decreasing order (\code{FALSE} by default)?}

\item{.na.last}{How to treat missing values in groups? Assign them to the last
group by default (\code{TRUE}).}

\item{.return.groups}{If \code{TRUE}, the grouping variables are returned in the GRP
object (default).}

\item{.return.order}{If \code{TRUE}, the order of the grouping variables is
returned in the object (by default, same value as \verb{sort=}).}

\item{.method}{The algorithm to use for grouping:  \code{"radix"}, \code{"hash"}, or
\code{"auto"} (by default). \code{"auto"} chose \code{"radix"} when \code{sort = TRUE} and
\code{"hash"} otherwise.}

\item{.fn}{A function to use.}

\item{.cols}{The list of the column where to apply the transformation. For
the moment, only all existing columns, which means \code{.cols = everything()}
is implemented}

\item{.by}{A list of names of the columns to use for grouping the data.}

\item{.preserve}{When data is grouped, do we preserve grouping or recalculate
it according to the new data frame obtained?}

\item{.keep}{Which columns to keep. The default is \code{"all"}, possible values
are \code{"used"}, \code{"unused"}, or \code{"none"} (see \code{\link[=mutate]{mutate()}}).}

\item{.before}{Place new columns before this one.}

\item{.after}{Place new columns after this one.}

\item{.groups}{How to treat the grouping variables in the result? Possible
values are \code{"drop_last"} (default), \code{"drop"} (no grouping variables),
\code{"keep"} (keep all grouping variables), or \code{"rowwise"} (not implemented
yet).}

\item{.keep.group_vars}{If \code{TRUE} (by default), the grouping variables are
kept in the result.}

\item{.by_group}{Logical. If \code{TRUE} rows are first arranger by the grouping
variables in any. \code{FALSE} by default.}

\item{.locale}{The locale to sort character vectors in. If \code{NULL}(default),
use \code{"C"} locale.}

\item{var}{A variable specified as a name, a positive or a negative integer
(counting from the end). The default is \code{-1} and returns last variable.}

\item{name}{The name of the new column in the output (\code{n} by default, and no
existing column must have this name, or an error is generated).4}

\item{y}{A second data frame.}

\item{by}{A list of names of the columns to use for joining the two data
frames. Could also be a join specification created with \code{\link[dplyr:join_by]{dplyr::join_by()}},
but in this case, calculation is delegated to dplyr's join methods.}

\item{copy}{This argument is there for compatibility with the "t" matching
functions, but it is not used here.}

\item{suffix}{The suffix to the column names to use to differentiate the
columns that come from the first or the second data frame. By default it is
\code{c(".x", ".y")}.}

\item{keep}{Should the join keys from both \code{x} and \code{y} be preserved in the
output? If \code{NULL}, the default, joins on equality retain only the keys from
\code{x}, while joins on inequality retain the keys from both inputs. If \code{TRUE},
all keys from both inputs are retained. If \code{FALSE}, only keys from \code{x} are
retained. For right and full joins, the data in key columns corresponding to
rows that only exist in \code{y} are merged into the key columns from \code{x}. Can't
be used when joining on inequality conditions. If \code{keep = TRUE}, calculation
is delegated to dplyr join methods.}

\item{na_matches}{Should two \code{NA} or two \code{NaN} values match? \code{"na"}, the
default, treats two \code{NA} or two \code{NaN} values as equal, like \code{\%in\%},
\code{match()}, \verb{and merge()}. \code{"never"} treats two \code{NA} or two \code{NaN} values as
different, and will never match them together or to any other values. This is
similar to joins for database sources and to
\code{base::merge(incomparables = NA)}. If \code{"never"}, calculation is delegated to
dplyr join methods.}

\item{multiple}{Handling of rows in \code{x} with multiple matches in \code{y}. For
each row of \code{x}: \code{"all"}, the default, returns every match detected in \code{y}.
This is the same behavior as SQL. \code{"any"} returns one match detected in \code{y},
with no guarantees on which match will be returned. It is often faster than
\code{"first"} and \code{"last"} in dplyr, but avoid it here. \code{"first"} returns the
first match detected in \code{y}. \code{"last"} returns the last match detected in \code{y}.
For \code{"any"} and \code{"last"}, calculation is delegated to dplyr join methods, and
in the case of right join, also for \code{"first"}..}

\item{unmatched}{How should unmatched keys that would result in dropped rows
be handled? \code{"drop"} drops unmatched keys from the result. \code{"error"} throws
an error if unmatched keys are detected. Also, a named list of the form
\code{list(x = 1, y = 0.5, fail = "warning")}can be used when calculation is
\strong{not} delegated to dplyr. The first two elements are the proportions that
must match, and the third element is \code{"message"}, \code{"warning"}, or \code{"error"}.}

\item{relationship}{Handling of the expected relationship between the keys of
\code{x} and \code{y}. If the expectations chosen from the list below are invalidated,
an error is thrown. \code{NULL}, the default, doesn't expect there to be any
relationship between \code{x} and \code{y}. However, for equality joins it will check
for a many-to-many relationship (which is typically unexpected) and will warn
if one occurs, encouraging you to either take a closer look at your inputs or
make this relationship explicit by specifying "many-to-many". \code{"one-to-one"}
expects: Each row in x matches at most 1 row in y. Each row in y matches at
most 1 row in x. \code{"one-to-many"} expects:  Each row in y matches at most 1
row in x. "many-to-one" expects: Each row in x matches at most 1 row in y.
\code{"many-to-many"} doesn't perform any relationship checks, but is provided to
allow you to be explicit about this relationship if you know it exists.
\code{relationship} doesn't handle cases where there are zero matches. For that,
see \code{unmatched}.}

\item{sort}{If \code{TRUE} largest group will be shown on top.}

\item{verbose}{integer. Prints information about the join. One of \code{0} (off),
\code{1} (default) or \code{2} (additionally prints the classes of the \code{by} columns).}

\item{column}{name for an extra column to generate in the output indicating
which dataset a record came from. \code{TRUE} calls this column \code{".join"}, or give
another name.}

\item{attr}{name for attribute providing information about the join performed
(including the output of \code{\link[collapse:fmatch]{collapse::fmatch()}}) to the result. \code{TRUE} calls
this attribute \code{"join.match"} or give your own name. Note: this also invokes
the count argument to \code{\link[collapse:fmatch]{collapse::fmatch()}}.}

\item{how}{Can be "full" (default), "inner", "left", "right", "semi", or "anti".}

\item{.id}{The name of the column for the origin id, either names if all
other arguments are named, or numbers.}

\item{.use_names}{If \code{TRUE} (default), bind by matching names, if \code{FALSE}, bind by
position. If \code{NULL}, warns if  all items do not have the same name in the
same order, and then proceeds as if \code{FALSE} (but will be as if \code{TRUE} in
the future).}

\item{.fill}{If \code{TRUE} (default), fills missing columns with \code{NA} or \code{NULL}
for missing list columns, if \code{FALSE}, do not fill.}

\item{.name_repair}{How should the name be "repaired" to avoid duplicate
column names? See \code{\link[dplyr:bind_cols]{dplyr::bind_cols()}} for more details.}

\item{n}{Number of rows to keep}

\item{prop}{Proportion of rows to keep, between 0 and 1. Provide either \code{n},
or \code{prop} but not both simultaneously. If none is provided, \code{n = 1} is used.}

\item{wt}{Frequency weights. Can be \code{NULL} or a variable. Use data masking.}

\item{decreasing}{Is sorting done in decreasing order (\code{FALSE} by default)?}

\item{add}{Add counts to the data frame (\code{FALSE} by default).}

\item{.keep_all}{If \code{TRUE} keep all variables in \code{.data}.}

\item{.na.attr}{logical. \code{TRUE} adds an attribute containing the removed
cases. For compatibility reasons this is exactly the same format as
\code{\link[=na.omit]{na.omit()}}, i.e. the attribute is called "na.action" and of class \strong{omit}}

\item{.prop}{numeric. The proportion missing values in each case for the case
to be considered as missing required to keep a}

\item{replace}{If \code{data} is a vector, a unique value to replace \code{NA}s,
otherwise, a list of values, one per column of the data frame.}

\item{v}{a vector where to replace NAs.}

\item{cols}{A selection of the columns using tidy-select syntax,
see\code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}}.}

\item{cols_vary}{character. Either "fastest" or "slowest". If "fastest"
(default), keep individual rows from \code{cols} close together. If "slowest",
keeps individual columns from `cols' close together.}

\item{names_to}{A character vector with the name or names of the columns for
the names.}

\item{names_prefix}{character. A regular expression used to remove matching text from the start of each variable name.}

\item{values_to}{A string with the name of the column that receives the
values.}

\item{values_drop_na}{logical. If \code{TRUE}, drop rows with only \code{NA}s in the
\code{values_to} column.}

\item{factor}{logical. If \code{TRUE}, convert the names and labels into factors,
if \code{FALSE} (default) leave then as character strings (but slower for
subsequent filtering).}

\item{id_cols}{A set of columns that uniquely identify each observation.}

\item{id_expand}{logical. If \code{TRUE}, expand the \code{id_cols}.}

\item{names_from}{The column or columns containing the names (use tidy
selection and do not quote the names).}

\item{names_vary}{character. How the various column names are made: "fastest"
(default), "slowest", "transpose", or "slowtranspose".}

\item{values_from}{Idem for the column or columns that contain the values.}

\item{values_fill}{Optionally, a scalar value to use for missing values.}

\item{values_fn}{Either the name of an internal function (as a string) :
"first", "last" (default), "count", "sum", "mean", "min", or "max". Could
also be a formula calling an external function with first argument being \code{.x}
like \code{~fmedian(.x, na.rm = TRUE)}.`}

\item{drop}{Drop unused factor levels or not.}

\item{weights}{A vector of weight to use to "uncount" \code{data}.}

\item{.remove}{If \code{TRUE}, and \code{weights} is the name of a column, that column
is removed from \code{data}.}

\item{col}{The name quoted or not of the new column with united variable.}

\item{sep}{Separator to use between values for united or separated columns.}

\item{remove}{If \code{TRUE} the initial columns that are separated are also
removed from \code{data}.}

\item{na.rm}{If \code{TRUE}, \code{NA}s are eliminated before uniting the values.}

\item{.direction}{Direction in which to fill missing data: \code{"down"} (by
default), \code{"up"}, or \code{"downup"} (first down, then up), \code{"updown"}
(the opposite).}

\item{into}{Name of the new column to put separated variables. Use \code{NA} for
items to drop.}

\item{convert}{If \verb{'TRUE} resulting values are converted into numeric,
integer or logical.}

\item{extra}{When \code{sep} is a character vector what happens when there are too
many pieces: \code{"warn"} (default) issue a warning and drop extra items,
\code{"drop"} does the same without warning and \code{"merge"} merges the extra items
with the last one.}

\item{fill}{When \code{sep} is a character vector what happens when there are not
enough pieces: \code{"warn"} (default) issue a warning and fill with \code{NA}s at
right, so does without warning \code{"right"}, and \code{"left"} fills with \code{NA}s at
left.}

\item{fixed}{logical. If \code{TRUE}, \code{sep} is a fixed string, otherwise it is a
(perl) regular expression.}

\item{data}{A data frame, or for \code{replace_na()} a vector or a data frame.}
}
\value{
See corresponding "non-SciViews" function for the full help page with
indication of the return values.
}
\description{
A SciViews::R version of the tidyverse functions in \{dplyr\}
and \{tidyr\} with standard evaluation, and non-standard evaluation trough
formulas. These functions end with an underscore \verb{_}. Avoid mixing tidy,
speedy and SciViews functions in the same pipeline.
}
\note{
The \code{summarise_()} function does not support \code{n()} as does
\code{\link[dplyr:summarise]{dplyr::summarise()}}. You can use \code{\link[svBase:fstat_functions]{svBase::fn()}} instead, but then, you must
give a variable name as argument. The \code{\link[svBase:fstat_functions]{svBase::fn()}} alternative can also be
used in \code{\link[dplyr:summarise]{dplyr::summarise()}} for homogeneous syntax between the two.
From \{dplyr\}, the \code{slice_min()}, \code{slice_max()} and \code{splice_sample()}
functions are not added yet.
From \{tidyr\} \code{\link[tidyr:expand]{tidyr::expand()}}, \code{\link[tidyr:chop]{tidyr::chop()}}, \code{\link[tidyr:chop]{tidyr::unchop()}},
\code{\link[tidyr:nest]{tidyr::nest()}}, \code{\link[tidyr:unnest]{tidyr::unnest()}}, \code{\link[tidyr:unnest_longer]{tidyr::unnest_longer()}},
\code{\link[tidyr:unnest_wider]{tidyr::unnest_wider()}}, \code{\link[tidyr:hoist]{tidyr::hoist()}}, \code{\link[tidyr:pack]{tidyr::pack()}} and
\code{\link[tidyr:pack]{tidyr::unpack()}} are not implemented yet.
}
\examples{
# TODO...
}
